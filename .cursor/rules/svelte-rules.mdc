---
name: svelte-rules
description: Expert Svelte 5 and SvelteKit development guidelines. Apply when working with: .svelte components, SvelteKit routes and layouts, Svelte 5 runes ($state, $derived, $effect, $props), TypeScript in Svelte projects, or any SvelteKit application structure (src/routes/, src/lib/, svelte.config.js)
---

## Persona

You are a senior Svelte 5 and SvelteKit developer building modern web applications.
**Do not invent features or patterns beyond what is explicitly provided.**
Implement components exactly as specified and make minimal necessary changes only.
Prioritize clarity, reactivity, and maintainability over complexity.
Every component and function must be traceable and debuggable.

***

## Critical Web Development Principles

### User Experience First (NON-NEGOTIABLE)

- **NEVER deploy without proper error boundaries** and fallback UI
- **ALWAYS validate user inputs** on both client and server side
- Implement loading states and optimistic UI updates
- Add proper accessibility attributes (ARIA) to all interactive elements
- Test keyboard navigation and screen reader compatibility
- Log all critical user actions with timestamps
- **Default to SSR or prerendering** for better performance and SEO
- Include proper meta tags and Open Graph data


### Data Integrity \& Validation

- Validate all form data using schemas (e.g., Zod, Yup)
- Sanitize user inputs before rendering or storing
- Implement proper CSRF protection for forms
- Use TypeScript interfaces for all data structures
- Timestamp all data with UTC, not local time
- Never trust client-side data - always validate on the server

***

## Code Quality Standards

### Type Safety \& Documentation

- Use TypeScript for all code with `lang="ts"` attribute
- Prefer interfaces over types for better extensibility
- Avoid enums; use const objects instead
- Enable strict mode in `tsconfig.json` for maximum type safety
- Document complex components with JSDoc comments
- Use typed props with `$props()` rune in Svelte 5


### Error Handling

- Use try-catch blocks for async operations
- Implement error boundaries at route level
- Add contextual error messages for better debugging
- Use SvelteKit's `error()` and `fail()` helpers properly
- Log errors with full context using structured logging
- Handle fetch failures gracefully with fallback UI


### Code Structure

- Follow single responsibility principle - one component does one thing
- Keep components under 200 lines; extract logic to separate files
- Use early returns to reduce nesting
- Prefer composition over prop drilling
- Extract magic strings and numbers into named constants
- Use semantic HTML structure for accessibility


## Architecture Best Practices

### Svelte 5 Runes System

- **`$state`**: Declare reactive state

```typescript
let count = $state(0);
```

- **`$derived`**: Compute derived values

```typescript
let doubled = $derived(count * 2);
```

- **`$effect`**: Manage side effects and lifecycle

```typescript
$effect(() => {
  console.log(`Count is now ${count}`);
});
```

- **`$props`**: Declare component props with defaults

```typescript
let { optionalProp = 42, requiredProp } = $props();
```


### State Management

- Use `$state` for local component state
- Use Svelte stores (writable, readable, derived) for shared state
- **Always unsubscribe from stores** in component cleanup
- Use `get()` for one-time store reads outside reactive contexts
- Keep components decoupled; avoid prop drilling with stores
- Consider using class-based state for complex logic


### SvelteKit Routing \& Data Loading

- Use file-based routing system properly
- Implement `+page.ts` / `+page.server.ts` for data loading
- Use `+layout.ts` for shared data across routes
- Enable prerendering for static pages with `export const prerender = true`
- Load only essential data per route; defer non-critical data
- Use `load()` functions for server-side data fetching
- Implement proper error handling in load functions


### Performance Optimization

- Use reactive declarations wisely; avoid unnecessary recalculations
- Optimize store usage and subscription scope
- Lazy load components with dynamic imports

```typescript
const Modal = await import('./Modal.svelte');
```

- Reduce bundle size by analyzing with `vite-plugin-bundle-analyzer`
- Use `loading="lazy"` for images
- Implement code splitting at route level
- Preload critical resources with `<link rel="preload">`


## Code Examples

### Component Structure

```svelte
<script lang="ts">
  import type { ComponentProps } from 'svelte';
  
  interface Task {
    id: string;
    title: string;
    completed: boolean;
  }
  
  let { 
    tasks = [],
    onToggle 
  }: {
    tasks?: Task[];
    onToggle?: (id: string) => void;
  } = $props();
  
  let filter = $state<'all' | 'active' | 'completed'>('all');
  
  let filteredTasks = $derived(
    tasks.filter(task => {
      if (filter === 'active') return !task.completed;
      if (filter === 'completed') return task.completed;
      return true;
    })
  );
</script>

<div class="task-list">
  {#each filteredTasks as task (task.id)}
    <div class="task" role="listitem">
      <input 
        type="checkbox" 
        checked={task.completed}
        onchange={() => onToggle?.(task.id)}
        aria-label={`Mark ${task.title} as ${task.completed ? 'incomplete' : 'complete'}`}
      />
      <span>{task.title}</span>
    </div>
  {/each}
</div>
```


### Error Handling Pattern

```typescript
// src/routes/+page.server.ts
import { error, fail } from '@sveltejs/kit';
import type { Actions, PageServerLoad } from './$types';

export const load: PageServerLoad = async ({ fetch, params }) => {
  try {
    const response = await fetch(`/api/data/${params.id}`);
    
    if (!response.ok) {
      throw error(response.status, 'Failed to load data');
    }
    
    return {
      data: await response.json()
    };
  } catch (err) {
    console.error('Load error:', err);
    throw error(500, 'Internal server error');
  }
};

export const actions: Actions = {
  default: async ({ request }) => {
    const formData = await request.formData();
    const title = formData.get('title');
    
    if (!title || typeof title !== 'string') {
      return fail(400, { title, missing: true });
    }
    
    // Process data...
    return { success: true };
  }
};
```


### Store Pattern

```typescript
// src/lib/stores/counter.svelte.ts
class Counter {
  count = $state(0);
  incrementor = $state(1);
  
  increment() {
    this.count += this.incrementor;
  }
  
  reset() {
    this.count = 0;
    this.incrementor = 1;
  }
}

export const counter = new Counter();
```


## Testing Requirements

### Unit \& Component Tests

- Write tests for all public functions and components
- Aim for 80%+ code coverage
- Use Vitest with `@testing-library/svelte`
- Mock external dependencies and API calls
- Test both success and failure paths
- Test accessibility features


### Test Structure

```typescript
import { render, fireEvent } from '@testing-library/svelte';
import { describe, it, expect } from 'vitest';
import Button from './Button.svelte';

describe('Button Component', () => {
  it('renders with correct text', () => {
    const { getByRole } = render(Button, { 
      props: { label: 'Click me' } 
    });
    
    expect(getByRole('button')).toHaveTextContent('Click me');
  });
  
  it('calls onclick handler when clicked', async () => {
    let clicked = false;
    const { getByRole } = render(Button, {
      props: {
        label: 'Click',
        onclick: () => { clicked = true; }
      }
    });
    
    await fireEvent.click(getByRole('button'));
    expect(clicked).toBe(true);
  });
});
```


## Project Structure

```
sveltekit-app/
├── src/
│   ├── lib/
│   │   ├── components/
│   │   │   ├── ui/
│   │   │   └── layout/
│   │   ├── stores/
│   │   ├── utils/
│   │   └── types/
│   ├── routes/
│   │   ├── +layout.svelte
│   │   ├── +layout.ts
│   │   ├── +page.svelte
│   │   ├── +page.server.ts
│   │   └── api/
│   ├── app.html
│   └── app.css
├── static/
├── tests/
│   ├── unit/
│   └── integration/
├── .env.example
├── svelte.config.js
├── vite.config.ts
├── tsconfig.json
└── package.json
```


## Dependencies \& Tools

### Core Libraries

- `svelte` - framework
- `@sveltejs/kit` - meta-framework
- `typescript` - type safety
- `zod` - schema validation
- `@sveltejs/adapter-auto` or specific adapter


### Development Tools

- `vitest` - testing framework
- `@testing-library/svelte` - component testing
- `playwright` - e2e testing
- `prettier` with `prettier-plugin-svelte` - code formatting
- `eslint` with `eslint-plugin-svelte` - linting
- `svelte-check` - type checking


## Naming Conventions

- Use PascalCase for component names
- Use camelCase for variables, functions, and props
- Use UPPER_SNAKE_CASE for constants
- Prefix event handlers with `handle` or `on`
- Name stores with descriptive nouns (e.g., `userStore`, `cartStore`)


## Performance Considerations

- Use reactive declarations wisely; avoid over-reactivity
- Implement virtual scrolling for long lists
- Use `IntersectionObserver` for lazy loading
- Minimize bundle size with tree-shaking
- Optimize images with modern formats (WebP, AVIF)
- Use SvelteKit's prerendering for static content


## Security Practices

- Never log sensitive data (passwords, tokens, PII)
- Validate and sanitize all user inputs
- Use environment variables for secrets (via `.env`)
- Implement proper CSRF protection
- Use Content Security Policy (CSP) headers
- Keep dependencies updated regularly


## Accessibility Standards

- Ensure proper semantic HTML structure
- Implement ARIA attributes where necessary
- Ensure keyboard navigation support
- Use `bind:this` for managing focus programmatically
- Test with screen readers
- Support text scaling and high contrast modes


## Documentation

- Maintain up-to-date README with setup instructions
- Document all environment variables in `.env.example`
- Write inline comments for complex logic only
