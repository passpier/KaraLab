import { json } from '@sveltejs/kit';
// @ts-expect-error - Generated by SvelteKit at runtime
import { env } from '$env/dynamic/private';
import { detectVideoType, formatDuration } from '$lib/utils/youtube';
import type { RequestHandler } from './$types';

export const GET: RequestHandler = async ({ url }: { url: URL }) => {
	const query = url.searchParams.get('q');
	const filter = url.searchParams.get('filter') || 'karaoke';
	const maxResults = parseInt(url.searchParams.get('maxResults') || '10', 10);
	
	if (!query) {
		return json({ error: 'Query parameter "q" is required' }, { status: 400 });
	}
	
	const apiKey = env.YOUTUBE_API_KEY;
	if (!apiKey) {
		console.error('YOUTUBE_API_KEY is missing. Check your .env file.');
		return json({ error: 'YouTube API key not configured. Please check your .env file and restart the dev server.' }, { status: 500 });
	}
	
	try {
		// Search for videos
		const searchUrl = new URL('https://www.googleapis.com/youtube/v3/search');
		searchUrl.searchParams.set('part', 'snippet');
		searchUrl.searchParams.set('q', `${query} ${filter === 'karaoke' ? 'karaoke instrumental' : filter === 'vocal' ? 'original' : ''}`);
		searchUrl.searchParams.set('type', 'video');
		searchUrl.searchParams.set('maxResults', Math.min(maxResults, 50).toString());
		searchUrl.searchParams.set('key', apiKey);
		
		const searchResponse = await fetch(searchUrl.toString());
		if (!searchResponse.ok) {
			const errorData = await searchResponse.json().catch(() => ({}));
			const errorMessage = errorData.error?.message || searchResponse.statusText;
			throw new Error(`YouTube API search error: ${errorMessage} (${searchResponse.status})`);
		}
		
		const searchData = await searchResponse.json();
		
		if (!searchData.items || searchData.items.length === 0) {
			return json({ videos: [] });
		}
		
		// Get video details including duration
		const videoIds = (searchData.items as Array<{ id: { videoId: string } }>).map(item => item.id.videoId).join(',');
		const detailsUrl = new URL('https://www.googleapis.com/youtube/v3/videos');
		detailsUrl.searchParams.set('part', 'snippet,contentDetails');
		detailsUrl.searchParams.set('id', videoIds);
		detailsUrl.searchParams.set('key', apiKey);
		
		const detailsResponse = await fetch(detailsUrl.toString());
		if (!detailsResponse.ok) {
			const errorData = await detailsResponse.json().catch(() => ({}));
			const errorMessage = errorData.error?.message || detailsResponse.statusText;
			throw new Error(`YouTube API details error: ${errorMessage} (${detailsResponse.status})`);
		}
		
		const detailsData = await detailsResponse.json() as {
			items: Array<{
				id: string;
				snippet: {
					title: string;
					description: string;
					channelTitle: string;
					publishedAt: string;
					thumbnails: {
						medium?: { url: string };
						default: { url: string };
					};
				};
				contentDetails?: { duration: string };
			}>;
		};
		
		// Combine search and details data
		const videos = detailsData.items.map((item) => {
			const videoType = detectVideoType(
				item.snippet.title,
				item.snippet.description
			);
			
			return {
				id: item.id,
				title: item.snippet.title,
				channelTitle: item.snippet.channelTitle,
				thumbnail: item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default.url,
				duration: item.contentDetails?.duration || '',
				publishedAt: item.snippet.publishedAt,
				videoType
			};
		});
		
		// Filter videos by videoType
		const filteredVideos = videos.filter((v) => v.videoType === filter);
		
		return json({ videos: filteredVideos });
	} catch (err) {
		const error = err instanceof Error ? err : new Error('Unknown error');
		console.error('YouTube search error:', error);
		return json({ error: error.message || 'Failed to search YouTube' }, { status: 500 });
	}
};
